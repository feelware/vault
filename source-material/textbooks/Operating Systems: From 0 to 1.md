# Operating Systems: From 0 to 1

## Problem domains

* **Problem domain**
  * Area of knowledge **not related to programming** relevant to the development of the software.
  * For instance, to write a finance application, a developer needs to learn sufficient finance concepts to understand and implement the *requirements* of the stakeholders.

* It's often **easier** for a domain expert to learn enough programming to break the problem into requirements (or even **write the code themselves**), than it is for software engineers to understand enough of the problem domain to know what to build.

* Operating systems development is an example of this:
  * Computer science (CS) students either invest a lot of time studying electrical engineering (EE) or rely on frameworks that abstract away many of the implementation details.
  * On the other hand, it's usually enough for EE students to learn C Programming and Algorithms and Data Structures to start writing device drivers and, as an extension, operating systems.

> At the minimum, a software engineer should be knowledgeable enough to understand the **documents prepared by hardware engineers** for using (i.e. programming) their devices.

* Knowing programming languages like Assembly or C++ alone won't make you good at low-level programming. Understanding the problem domain is crucial.
